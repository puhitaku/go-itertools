// This is a translated example of fizzbuzz.go2.
// Code generated by go2go; DO NOT EDIT.


//line fizzbuzz.go2:1
package main

//line fizzbuzz.go2:1
import (
//line fizzbuzz.go2:6
 iter "github.com/puhitaku/go2-itertools/itertools"
//line fizzbuzz.go2:6
 "crypto/sha256"
//line fizzbuzz.go2:6
 "encoding/hex"
//line fizzbuzz.go2:6
 "fmt"
//line fizzbuzz.go2:6
 "math/rand"
//line fizzbuzz.go2:6
 "sort"
//line fizzbuzz.go2:6
 "time"
//line fizzbuzz.go2:6
)

//line fizzbuzz.go2:9
func main() {
	threes := instantiate୦itertools୦MapC୦int୦bool(func(i int) bool { return i%3 == 0 }, instantiate୦itertools୦Count୦int(1))
	fives := instantiate୦itertools୦MapC୦int୦bool(func(i int) bool { return i%5 == 0 }, instantiate୦itertools୦Count୦int(1))
	fb := instantiate୦itertools୦Zip2C୦bool୦bool(threes, fives)

	for i := 0; i < 15; i++ {
		t := <-fb

		if t.V1 && t.V2 {
			fmt.Printf("fizzbuzz\n")
		} else if t.V1 {
			fmt.Printf("fizz\n")
		} else if t.V2 {
			fmt.Printf("buzz\n")
		} else {
			fmt.Printf("%02d\n", i+1)
		}
	}
}
func instantiate୦itertools୦MapC୦int୦bool(fn func(v int) bool, it <-chan int) <-chan bool {
	c := make(chan bool)
	go func() {
		for v := range it {
			c <- fn(v)
		}
		close(c)
	}()
	return c
}
func instantiate୦itertools୦Count୦int(start int) chan int {
	c := make(chan int)
	v := start
	go func() {
		for {
			for {
				c <- v
				v++
			}
		}
	}()
	return c
}
func instantiate୦itertools୦Zip2C୦bool୦bool(it1 <-chan bool, it2 <-chan bool) chan instantiate୦itertools୦Tuple2୦bool୦bool {
	var dummy1 bool
	var dummy2 bool
	return instantiate୦itertools୦zip2c୦bool୦bool(it1, it2, dummy1, dummy2, false)
}

//line :1
type instantiate୦itertools୦Tuple2୦bool୦bool struct {
	V1 bool
	V2 bool
}

func instantiate୦itertools୦zip2c୦bool୦bool(it1 <-chan bool, it2 <-chan bool, f1 bool, f2 bool, longest bool) chan instantiate୦itertools୦Tuple2୦bool୦bool {
	c := make(chan instantiate୦itertools୦Tuple2୦bool୦bool)
	go func() {
		defer close(c)
		var v1 bool
		var v2 bool
		var closed = make([]bool, 2)
		var ok bool
		for {
			select {
			case v1, ok = <-it1:
				if !ok {
					closed[0] = true
				}
				v2, ok = <-it2
				if !ok {
					closed[1] = true
				}
			case v2, ok = <-it2:
				if !ok {
					closed[1] = true
				}
				v1, ok = <-it1
				if !ok {
					closed[0] = true
				}
			}
			if closed[0] || closed[1] {
				if (closed[0] && closed[1]) || !longest {
					return
				}
				if closed[0] {
					v1 = f1
				}
				if closed[1] {
					v2 = f2
				}
			}
			c <- instantiate୦itertools୦Tuple2୦bool୦bool{V1: v1, V2: v2}
		}
	}()
	return c
}

//line :1
type Importable୦ int
//line :1
type _ iter.Importable୦

//line :1
const _ = sha256.BlockSize

//line :1
var _ = hex.Decode
//line :1
var _ = fmt.Errorf
//line :1
var _ = rand.ExpFloat64

//line :1
type _ sort.Float64Slice

//line :1
const _ = time.ANSIC
