package main

import (
	"reflect"
	"testing"

	"github.com/puhitaku/go2-itertools/itertools"
)

type Point struct {
	X, Y int
}

func (p Point) Add(v Point) Point {
	return Point{X: p.X + v.X, Y: p.Y + v.Y}
}

func (p Point) Eq(v Point) bool {
	return p.X == v.X && p.Y == v.Y
}

func TestFinite(t *testing.T) {
	t.Run("Accumulate", testAccumulate)
	t.Run("AccumulateIface", testAccumulateIface)
	t.Run("Chain", testChain)
	t.Run("ChainFromIterable", testChainFromIterable)
	t.Run("Compress", testCompress)
	t.Run("DropWhile", testDropWhile)
	t.Run("TakeWhile", testTakeWhile)
	t.Run("FilterFalse", testFilterFalse)
	t.Run("GroupBy", testGroupBy)
	t.Run("GroupByIface", testGroupByIface)
	t.Run("ISlice", testISlice)
	t.Run("Tee", testTee)
	t.Run("ZipLongest", testZipLongest)
}

func testAccumulate(t *testing.T) {
	input := []int{1, 2, 3, 4, 5}
	output := itertools.ToSlice(itertools.Accumulate(itertools.ToChan(input)))
	expect := []int{1, 3, 6, 10, 15}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}

	output = itertools.ToSlice(itertools.AccumulateS(input))

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testAccumulateIface(t *testing.T) {
	input := []Point{{1, 2}, {4, 5}, {1, 1}}
	output := itertools.ToSlice(itertools.AccumulateIface(itertools.ToChan(input)))
	expect := []Point{{1, 2}, {5, 7}, {6, 8}}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}

	output = itertools.ToSlice(itertools.AccumulateIfaceS(input))

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testChain(t *testing.T) {
	s1, s2, s3 := []int{1, 2}, []int{5, 6}, []int{1, 1}
	c1, c2, c3 := itertools.ToChan(s1), itertools.ToChan(s2), itertools.ToChan(s3)
	output := itertools.ToSlice(itertools.Chain(c1, c2, c3))
	expect := []int{1, 2, 5, 6, 1, 1}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}

	output = itertools.ToSlice(itertools.ChainS(s1, s2, s3))

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testChainFromIterable(t *testing.T) {
	s1, s2, s3 := []int{1, 2}, []int{5, 6}, []int{1, 1}
	c1, c2, c3 := itertools.ToChan(s1), itertools.ToChan(s2), itertools.ToChan(s3)
	output := itertools.ToSlice(itertools.ChainFromIterable([]<-chan int{c1, c2, c3}))
	expect := []int{1, 2, 5, 6, 1, 1}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}

	output = itertools.ToSlice(itertools.ChainFromIterableS([][]int{s1, s2, s3}))

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testCompress(t *testing.T) {
	d := []int{1, 2, 3, 4, 5, 6}
	sel := []bool{true, false, true, false, true}
	output := itertools.ToSlice(itertools.Compress(itertools.ToChan(d), itertools.ToChan(sel)))
	expect := []int{1, 3, 5}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}

	output = itertools.ToSlice(itertools.CompressS(d, sel))

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testDropWhile(t *testing.T) {
	pred := func(v int) bool { return v < 5 }
	seq := []int{1, 4, 6, 4, 1}
	output := itertools.ToSlice(itertools.DropWhile(pred, itertools.ToChan(seq)))
	expect := []int{6, 4, 1}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}

	output = itertools.ToSlice(itertools.DropWhileS(pred, seq))

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testTakeWhile(t *testing.T) {
	pred := func(v int) bool { return v < 5 }
	seq := []int{1, 4, 6, 4, 1}
	output := itertools.ToSlice(itertools.TakeWhile(pred, itertools.ToChan(seq)))
	expect := []int{1, 4}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}

	output = itertools.ToSlice(itertools.TakeWhileS(pred, seq))

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testFilterFalse(t *testing.T) {
	pred := func(v int) bool { return v%2 == 0 }
	seq := []int{0, 1, 2, 3, 4, 5}

	output := itertools.ToSlice(itertools.FilterFalse(pred, itertools.ToChan(seq)))
	expect := []int{1, 3, 5}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}

	output = itertools.ToSlice(itertools.FilterFalseS(pred, seq))
	expect = []int{1, 3, 5}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testGroupBy(t *testing.T) {
	seq := []rune("aaaabbbccd")
	it := itertools.GroupBy(itertools.ToChan(seq))
	expect := [][]string{{"a", "aaaa"}, {"b", "bbb"}, {"c", "cc"}, {"d", "d"}}
	output := [][]string{}

	for group := range it {
		vs := itertools.ToSlice(group.Group)
		output = append(output, []string{string(group.Key), string(vs)})
	}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}

	it = itertools.GroupByS(seq)
	output = [][]string{}

	for group := range it {
		vs := itertools.ToSlice(group.Group)
		output = append(output, []string{string(group.Key), string(vs)})
	}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testGroupByIface(t *testing.T) {
	type testGroup struct {
		P Point
		N int
	}

	seq := []Point{
		{1, 2},
		{1, 2},
		{3, 2},
		{3, 4},
		{4, 3},
		{4, 3},
	}

	it := itertools.GroupByIface(itertools.ToChan(seq))
	expect := []testGroup{{Point{1, 2}, 2}, {Point{3, 2}, 1}, {Point{3, 4}, 1}, {Point{4, 3}, 2}}
	output := []testGroup{}

	for group := range it {
		n := len(itertools.ToSlice(group.Group))
		output = append(output, testGroup{group.Key, n})
	}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}

	it = itertools.GroupByIfaceS(seq)
	output = []testGroup{}

	for group := range it {
		n := len(itertools.ToSlice(group.Group))
		output = append(output, testGroup{group.Key, n})
	}

	if !reflect.DeepEqual(output, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testISlice(t *testing.T) {
	seq := []rune("ABCDEFG")

	// Skip beginning
	output := string(itertools.ToSlice(itertools.ISlice(itertools.ToChan(seq), 2, 0, 1)))
	expect := "CDEFG"

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// Skip beginning and end
	output = string(itertools.ToSlice(itertools.ISlice(itertools.ToChan(seq), 2, len(seq)-1, 1)))
	expect = "CDEF"

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// Skip beggining, skip 2
	output = string(itertools.ToSlice(itertools.ISlice(itertools.ToChan(seq), 2, 0, 2)))
	expect = "CEG"

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// Nothing to iterate
	output = string(itertools.ToSlice(itertools.ISlice(itertools.ToChan(seq), 3, 1, 1)))
	expect = ""

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// Skip beginning
	output = string(itertools.ToSlice(itertools.ISliceS(seq, 2, 0, 1)))
	expect = "CDEFG"

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// Skip beginning and end
	output = string(itertools.ToSlice(itertools.ISliceS(seq, 2, len(seq)-1, 1)))
	expect = "CDEF"

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// Skip beggining, skip 2
	output = string(itertools.ToSlice(itertools.ISliceS(seq, 2, 0, 2)))
	expect = "CEG"

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// Nothing to iterate
	output = string(itertools.ToSlice(itertools.ISliceS(seq, 3, 1, 1)))
	expect = ""

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}
}

func testTee(t *testing.T) {
	// FIXME: this test doesn't test if the tee'd channels are able to be consumed asynchronously.
	//        See /itertools/finite.go2 for further details.

	seq := []int{1, 2, 3, 4}
	its := itertools.Tee(itertools.ToChan(seq), 3)
	outputs := [3][]int{{}, {}, {}}
	expect := [3][]int{{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}}

	for i := 0; i < 4; i++ {
		for j, it := range its {
			outputs[j] = append(outputs[j], <-it)
		}
	}

	if !reflect.DeepEqual(outputs, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, outputs)
	}
}

func testZipLongest(t *testing.T) {
	s1, s2, s3, s4 := []int{1, 2}, []int{2, 3, 4, 5}, []int{9, 8, 7, 6, 5}, []int{0, -1, -2}

	// ZipLongest2
	z2 := itertools.ZipLongest2(itertools.ToChan(s1), itertools.ToChan(s2), 11, 22)
	expect := [][]int{{1, 2, 11, 11}, {2, 3, 4, 5}}
	v1, v2 := []int{}, []int{}

	for t := range z2 {
		v1, v2 = append(v1, t.V1), append(v2, t.V2)
	}

	output := [][]int{v1, v2}

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// ZipLongest2S
	z2s := itertools.ZipLongest2S(s1, s2, 11, 22)
	v1, v2 = []int{}, []int{}

	for t := range z2s {
		v1, v2 = append(v1, t.V1), append(v2, t.V2)
	}

	output = [][]int{v1, v2}

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// ZipLongest3
	z3 := itertools.ZipLongest3(itertools.ToChan(s1), itertools.ToChan(s2), itertools.ToChan(s3), 11, 22, 33)
	expect = [][]int{{1, 2, 11, 11, 11}, {2, 3, 4, 5, 22}, {9, 8, 7, 6, 5}}

	v1, v2, v3 := []int{}, []int{}, []int{}
	for t := range z3 {
		v1, v2, v3 = append(v1, t.V1), append(v2, t.V2), append(v3, t.V3)
	}

	output = [][]int{v1, v2, v3}

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// ZipLongest3S
	z3s := itertools.ZipLongest3S(s1, s2, s3, 11, 22, 33)
	expect = [][]int{{1, 2, 11, 11, 11}, {2, 3, 4, 5, 22}, {9, 8, 7, 6, 5}}

	v1, v2, v3 = []int{}, []int{}, []int{}
	for t := range z3s {
		v1, v2, v3 = append(v1, t.V1), append(v2, t.V2), append(v3, t.V3)
	}

	output = [][]int{v1, v2, v3}

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// ZipLongest4
	z4 := itertools.ZipLongest4(itertools.ToChan(s1), itertools.ToChan(s2), itertools.ToChan(s3), itertools.ToChan(s4), 11, 22, 33, 44)
	expect = [][]int{{1, 2, 11, 11, 11}, {2, 3, 4, 5, 22}, {9, 8, 7, 6, 5}, {0, -1, -2, 44, 44}}

	v1, v2, v3, v4 := []int{}, []int{}, []int{}, []int{}
	for t := range z4 {
		v1, v2, v3, v4 = append(v1, t.V1), append(v2, t.V2), append(v3, t.V3), append(v4, t.V4)
	}

	output = [][]int{v1, v2, v3, v4}

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}

	// ZipLongest4S
	z4s := itertools.ZipLongest4S(s1, s2, s3, s4, 11, 22, 33, 44)
	expect = [][]int{{1, 2, 11, 11, 11}, {2, 3, 4, 5, 22}, {9, 8, 7, 6, 5}, {0, -1, -2, 44, 44}}

	v1, v2, v3, v4 = []int{}, []int{}, []int{}, []int{}
	for t := range z4s {
		v1, v2, v3, v4 = append(v1, t.V1), append(v2, t.V2), append(v3, t.V3), append(v4, t.V4)
	}

	output = [][]int{v1, v2, v3, v4}

	if !reflect.DeepEqual(output, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, output)
	}
}
