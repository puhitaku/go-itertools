package main

import (
	"reflect"
	"testing"

	"github.com/puhitaku/go2-itertools/itertools"
)

type Point struct {
	X, Y int
}

func (p Point) Add(v Point) Point {
	return Point{X: p.X + v.X, Y: p.Y + v.Y}
}

func (p Point) Eq(v Point) bool {
	return p.X == v.X && p.Y == v.Y
}

func TestConv(t *testing.T) {
	t.Run("ToSlice", testToSlice)
	t.Run("ToChan", testToChan)
}

func TestInfinite(t *testing.T) {
	t.Run("Count", testCount)
	t.Run("Cycle", testCycle)
	t.Run("CycleS", testCycleS)
	t.Run("Repeat", testRepeat)
}

func TestFinite(t *testing.T) {
	t.Run("Accumulate", testAccumulate)
	t.Run("AccumulateIface", testAccumulateIface)
	t.Run("Chain", testChain)
	t.Run("ChainFromIterable", testChainFromIterable)
	t.Run("Compress", testCompress)
	t.Run("DropWhile", testDropWhile)
	t.Run("TakeWhile", testTakeWhile)
	t.Run("FilterFalse", testFilterFalse)
	t.Run("GroupBy", testGroupBy)
	t.Run("GroupByIface", testGroupByIface)
	t.Run("ISlice", testISlice)
	t.Run("Tee", testTee)
	t.Run("ZipLongest", testZipLongest)
}

func TestCombinatoric(t *testing.T) {
	t.Run("Product", testProduct)
	t.Run("Permutations", testPermutations)
	t.Run("Combinations", testCombinations)
	t.Run("CombinationsWithReplacement", testCombinationsWithReplacement)
}

func TestBuiltins(t *testing.T) {
	//t.Run("Zip", testZip)
}

func testToSlice(t *testing.T) {
	c := make(chan int)
	go func() {
		for i := 0; i < 5; i++ {
			c <- i
		}
		close(c)
	}()

	result := itertools.ToSlice(c)
	expect := []int{0, 1, 2, 3, 4}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testToChan(t *testing.T) {
	result := []int{}
	expect := []int{0, 1, 2, 3, 4}
	for v := range itertools.ToChan([]int{0, 1, 2, 3, 4}) {
		result = append(result, v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testCount(t *testing.T) {
	it := itertools.Count(10)
	expect := []int{10, 11, 12, 13}
	result := []int{}

	for i := 0; i < 4; i++ {
		result = append(result, <-it)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testCycle(t *testing.T) {
	it := itertools.Cycle(itertools.ToChan([]int{1, 2, 3}))
	expect := []int{1, 2, 3, 1, 2, 3, 1}
	result := []int{}

	for i := 0; i < 7; i++ {
		result = append(result, <-it)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testCycleS(t *testing.T) {
	it := itertools.CycleS([]int{1, 2, 3})
	expect := []int{1, 2, 3, 1, 2, 3, 1}
	result := []int{}

	for i := 0; i < 7; i++ {
		result = append(result, <-it)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testRepeat(t *testing.T) {
	it := itertools.Repeat(39, 4)
	expect := []int{39, 39, 39, 39}
	result := []int{}

	for v := range it {
		result = append(result, v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testAccumulate(t *testing.T) {
	it := itertools.Accumulate([]int{1, 2, 3, 4, 5})
	expect := []int{1, 3, 6, 10, 15}
	result := []int{}

	for v := range it {
		result = append(result, v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testAccumulateIface(t *testing.T) {
	it := itertools.AccumulateIface([]Point{{1, 2}, {4, 5}, {1, 1}})
	expect := []Point{{1, 2}, {5, 7}, {6, 8}}
	result := []Point{}

	for v := range it {
		result = append(result, v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testChain(t *testing.T) {
	it := itertools.Chain([]int{1, 2}, []int{5, 6}, []int{1, 1})
	expect := []int{1, 2, 5, 6, 1, 1}
	result := []int{}

	for v := range it {
		result = append(result, v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testChainFromIterable(t *testing.T) {
	it := itertools.ChainFromIterable([][]int{{1, 2}, {5, 6}, {1, 1}})
	expect := []int{1, 2, 5, 6, 1, 1}
	result := []int{}

	for v := range it {
		result = append(result, v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testCompress(t *testing.T) {
	data := []int{1, 2, 3, 4, 5, 6}
	selectors := []bool{true, false, true, false, true}
	it := itertools.Compress(data, selectors)
	expect := []int{1, 3, 5}
	result := []int{}

	for v := range it {
		result = append(result, v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testDropWhile(t *testing.T) {
	pred := func(v int) bool { return v < 5 }
	seq := []int{1, 4, 6, 4, 1}
	it := itertools.DropWhile(pred, seq)
	expect := []int{6, 4, 1}
	result := []int{}

	for v := range it {
		result = append(result, v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testTakeWhile(t *testing.T) {
	pred := func(v int) bool { return v < 5 }
	seq := []int{1, 4, 6, 4, 1}
	it := itertools.TakeWhile(pred, seq)
	expect := []int{1, 4}
	result := []int{}

	for v := range it {
		result = append(result, v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testFilterFalse(t *testing.T) {
	pred := func(v int) bool { return v%2 == 0 }
	seq := []int{0, 1, 2, 3, 4, 5}
	it := itertools.FilterFalse(pred, seq)
	expect := []int{0, 2, 4}
	result := []int{}

	for v := range it {
		result = append(result, v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testGroupBy(t *testing.T) {
	seq := []rune("aaaabbbccd")
	it := itertools.GroupBy(seq)
	expect := [][]string{{"a", "aaaa"}, {"b", "bbb"}, {"c", "cc"}, {"d", "d"}}
	result := [][]string{}

	for group := range it {
		vs := []rune{}
		for v := range group.Group {
			vs = append(vs, v)
		}
		result = append(result, []string{string(group.Key), string(vs)})
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testGroupByIface(t *testing.T) {
	type testGroup struct {
		P Point
		N int
	}

	seq := []Point{
		{1, 2},
		{1, 2},
		{3, 2},
		{3, 4},
		{4, 3},
		{4, 3},
	}

	it := itertools.GroupByIface(seq)
	expect := []testGroup{{Point{1, 2}, 2}, {Point{3, 2}, 1}, {Point{3, 4}, 1}, {Point{4, 3}, 2}}
	result := []testGroup{}

	for group := range it {
		n := 0
		for _ = range group.Group {
			n++
		}
		result = append(result, testGroup{group.Key, n})
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatal("the result did not match with the expected slice")
	}
}

func testISlice(t *testing.T) {
	seq := []rune("ABCDEFG")

	// Skip beginning
	it := itertools.ISlice(seq, 2, 0, 1)
	expect := "CDEFG"
	result := ""

	for v := range it {
		result += string(v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}

	// Skip beginning and end
	it = itertools.ISlice(seq, 2, len(seq)-1, 1)
	expect = "CDEF"
	result = ""

	for v := range it {
		result += string(v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}

	// Skip beggining, skip 2
	it = itertools.ISlice(seq, 2, 0, 2)
	expect = "CEG"
	result = ""

	for v := range it {
		result += string(v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}

	// Nothing to iterate
	it = itertools.ISlice(seq, 3, 1, 1)
	expect = ""
	result = ""

	for v := range it {
		result += string(v)
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}
}

func testTee(t *testing.T) {
	seq := []int{1, 2, 3, 4}
	its := itertools.Tee(seq, 3)

	for i := 0; i < 3; i++ {
		result := []int{}
		for v := range its[i] {
			result = append(result, v)
		}

		if !reflect.DeepEqual(result, seq) {
			t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", seq, result)
		}
	}
}

func testZipLongest(t *testing.T) {
	s1, s2, s3, s4 := []int{1, 2}, []int{2, 3, 4, 5}, []int{9, 8, 7, 6, 5}, []int{0, -1, -2}

	// ZipLongest2
	z2 := itertools.ZipLongest2(s1, s2, 11, 22)
	expect := [][]int{{1, 2, 11, 11}, {2, 3, 4, 5}}

	v1, v2 := []int{}, []int{}
	for t := range z2 {
		v1, v2 = append(v1, t.V1), append(v2, t.V2)
	}

	result := [][]int{v1, v2}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}

	// ZipLongest3
	z3 := itertools.ZipLongest3(s1, s2, s3, 11, 22, 33)
	expect = [][]int{{1, 2, 11, 11, 11}, {2, 3, 4, 5, 22}, {9, 8, 7, 6, 5}}

	v1, v2, v3 := []int{}, []int{}, []int{}
	for t := range z3 {
		v1, v2, v3 = append(v1, t.V1), append(v2, t.V2), append(v3, t.V3)
	}

	result = [][]int{v1, v2, v3}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}

	// ZipLongest4
	z4 := itertools.ZipLongest4(s1, s2, s3, s4, 11, 22, 33, 44)
	expect = [][]int{{1, 2, 11, 11, 11}, {2, 3, 4, 5, 22}, {9, 8, 7, 6, 5}, {0, -1, -2, 44, 44}}

	v1, v2, v3, v4 := []int{}, []int{}, []int{}, []int{}
	for t := range z4 {
		v1, v2, v3, v4 = append(v1, t.V1), append(v2, t.V2), append(v3, t.V3), append(v4, t.V4)
	}

	result = [][]int{v1, v2, v3, v4}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}
}

func testProduct(t *testing.T) {
	s1, s2, s3, s4 := []rune("AB"), []rune("xy"), []rune("12"), []rune("!?")

	// Product2
	p2 := itertools.Product2(s1, s2)
	expect := []string{"Ax", "Ay", "Bx", "By"}
	result := []string{}

	for t := range p2 {
		result = append(result, string(t.V1) + string(t.V2))
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}

	// Product3
	p3 := itertools.Product3(s1, s2, s3)
	expect = []string{"Ax1", "Ax2", "Ay1", "Ay2", "Bx1", "Bx2", "By1", "By2"}
	result = []string{}

	for t := range p3 {
		result = append(result, string(t.V1) + string(t.V2) + string(t.V3))
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}

	// Product4
	p4 := itertools.Product4(s1, s2, s3, s4)
	expect = []string{
		"Ax1!", "Ax1?", "Ax2!", "Ax2?", "Ay1!", "Ay1?", "Ay2!", "Ay2?",
		"Bx1!", "Bx1?", "Bx2!", "Bx2?", "By1!", "By1?", "By2!", "By2?",
	}
	result = []string{}

	for t := range p4 {
		result = append(result, string(t.V1) + string(t.V2) + string(t.V3) + string(t.V4))
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}
}

func testPermutations(t *testing.T) {
	s1, s2 := []rune("ABCD"), []rune("012")
	it1 := itertools.Permutations(s1, 2)
	expect := []string{"AB", "AC", "AD", "BA", "BC", "BD", "CA", "CB", "CD", "DA", "DB", "DC"}
	result := []string{}

	for v := range it1 {
		result = append(result, string(v))
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}

	it2 := itertools.Permutations(s2, 0)
	expect = []string{"012", "021", "102", "120", "201", "210"}
	result = []string{}

	for v := range it2 {
		result = append(result, string(v))
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}
}

func testCombinations(t *testing.T) {
	s1, s2 := []rune("ABCD"), []rune("0123")
	it1 := itertools.Combinations(s1, 2)
	expect := []string{"AB", "AC", "AD", "BC", "BD", "CD"}
	result := []string{}

	for v := range it1 {
		result = append(result, string(v))
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}

	it2 := itertools.Combinations(s2, 3)
	expect = []string{"012", "013", "023", "123"}
	result = []string{}

	for v := range it2 {
		result = append(result, string(v))
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}
}

func testCombinationsWithReplacement(t *testing.T) {
	s1 := []rune("ABC")
	it1 := itertools.CombinationsWithReplacement(s1, 2)
	expect := []string{"AA", "AB", "AC", "BB", "BC", "CC"}
	result := []string{}

	for v := range it1 {
		result = append(result, string(v))
	}

	if !reflect.DeepEqual(result, expect) {
		t.Fatalf("the result did not match with the expected slice: expect=%v, actual=%v", expect, result)
	}
}
