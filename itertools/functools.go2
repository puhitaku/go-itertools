package itertools

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
)

type LRUComparable[T Comparable, U any] struct {
	fn func(T) U
	cache map[T]U
	age map[T]int
	maxSize int
}

func WrapLRUComparable[T Comparable, U any](fn func(T) U, maxSize int) *LRUComparable[T, U] {
	return &LRUComparable[T, U]{
		fn: fn,
		cache: map[T]U{},
		age: map[T]int{},
		maxSize: maxSize,
	}
}

func (l *LRUComparable[T, U]) Call(arg T) U {
	var ret U

	cv, ok := l.cache[arg]
	if ok {
		ret = cv
	} else {
		ret = l.fn(arg)
		l.cache[arg] = ret
	}

	l.age[arg] = -1

	for k := range l.age {
		l.age[k] += 1
	}

	if len(l.age) > l.maxSize {
		var mk T
		var ma int

		for k, age := range l.age {
			if ma < age {
				mk, ma = k, age
			}
		}

		delete(l.cache, mk)
		delete(l.age, mk)
	}

	return ret
}

type LRUAny[T, U any] struct {
	fn func(T) U
	cache map[string]U
	age map[string]int
	maxSize int
}

func WrapLRUAny[T, U any](fn func(T) U, maxSize int) *LRUAny[T, U] {
	return &LRUAny[T, U]{
		fn: fn,
		cache: map[string]U{},
		age: map[string]int{},
		maxSize: maxSize,
	}
}

func (l *LRUAny[T, U]) Call(arg T) U {
	var ret U
	var sha = sha256.Sum256([]byte(fmt.Sprintf("%#v", arg)))
	var hashed = hex.EncodeToString(sha[:])

	cv, ok := l.cache[hashed]
	if ok {
		ret = cv
	} else {
		ret = l.fn(arg)
		l.cache[hashed] = ret
	}

	l.age[hashed] = -1

	for k := range l.age {
		l.age[k] += 1
	}

	if len(l.age) > l.maxSize {
		var mk string
		var ma int

		for k, age := range l.age {
			if ma < age {
				mk, ma = k, age
			}
		}

		delete(l.cache, mk)
		delete(l.age, mk)
	}

	return ret
}

type Hashable[T any] interface {
	Hash() []byte
}

type LRUHashable[T Hashable[T], U any] struct {
	fn func(T) U
	cache map[string]U
	age map[string]int
	maxSize int
}

func WrapLRUHashable[T Hashable[T], U any](fn func(T) U, maxSize int) *LRUHashable[T, U] {
	return &LRUHashable[T, U]{
		fn: fn,
		cache: map[string]U{},
		age: map[string]int{},
		maxSize: maxSize,
	}
}

func (l *LRUHashable[T, U]) Call(arg Hashable[T]) U {
	var ret U
	var hashed = l.hash(arg)

	cv, ok := l.cache[hashed]
	if ok {
		ret = cv
	} else {
		// Assertability of arg (Hashable[T]) to T is guaranteed in build time
		// because T must implement Hashable in order to instantiate generic LRUHashable[T, U]
		ret = l.fn(arg.(T))
		l.cache[hashed] = ret
	}

	l.age[hashed] = -1

	for k := range l.age {
		l.age[k] += 1
	}

	if len(l.age) > l.maxSize {
		var mk string
		var ma int

		for k, age := range l.age {
			if ma < age {
				mk, ma = k, age
			}
		}

		delete(l.cache, mk)
		delete(l.age, mk)
	}

	return ret
}

func (*LRUHashable[T, U]) hash(v Hashable[T]) string {
	return hex.EncodeToString(v.Hash())
}
