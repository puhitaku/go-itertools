// infinite: Inifinite iterators
// Functions declared here have different naming convention that
// they generally have no "C" in the end of their name even they output channels.

package itertools

// Count counts up a value from "start" and emits it infinitely.
// Bulit-in types that implements increment operator (++) are only supported.
// TODO: implement CountIface
func Count[T Incrementable](start T) chan T {
	c := make(chan T)
	v := start
	go func() {
		for {
			c <- v
			v++
		}
	}()
	return c
}

// Cycle emits the elements in the slice infinitely.
func Cycle[T any](iter []T) chan T {
	c := make(chan T)
	go func() {
		for {
			for _, v := range iter {
				c <- v
			}
		}
	}()
	return c
}

// CycleC is an alternative of Cycle that inputs a channel.
// The output is synchronized to the input and repeats it infinitely.
func CycleC[T any](iter <-chan T) chan T {
	c := make(chan T)
	buf := []T{}

	go func() {
		for v := range iter {
			buf = append(buf, v)
			c <- v
		}

		for {
			for i := range buf {
				c <- buf[i]
			}
		}
	}()
	return c
}

// Repeat repeats the argument value.
// The output channel will be finite if n > 0 and infinite if n == 0.
func Repeat[T any](v T, n int) chan T {
	c := make(chan T)
	go func() {
		for i := 0; n == 0 || i < n; i++ {
			c <- v
		}
		close(c)
	}()
	return c
}
