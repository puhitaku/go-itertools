// finite: Iterators terminating on the shortest input sequence

package itertools

func Accumulate[T Addable](iter <-chan T) chan T {
	c := make(chan T)
	var accum T

	go func() {
		for v := range iter {
			accum += v
			c <- accum
		}
		close(c)
	}()
	return c
}

func AccumulateS[T Addable](iter []T) chan T {
	c := make(chan T)
	var accum T

	go func() {
		for _, v := range iter {
			accum += v
			c <- accum
		}
		close(c)
	}()
	return c
}

func AccumulateIface[T AddableIface[T]](iter <- chan T) chan T {
	c := make(chan T)
	var accum T

	go func() {
		for v := range iter {
			accum = accum.Add(v)
			c <- accum
		}
		close(c)
	}()
	return c
}

func AccumulateIfaceS[T AddableIface[T]](iter []T) chan T {
	c := make(chan T)
	var accum T

	go func() {
		for _, v := range iter {
			accum = accum.Add(v)
			c <- accum
		}
		close(c)
	}()
	return c
}

func Chain[T any](iter ...<-chan T) chan T {
	c := make(chan T)

	go func() {
		for _, it := range iter {
			for v := range it {
				c <- v
			}
		}
		close(c)
	}()
	return c
}

func ChainS[T any](iter ...[]T) chan T {
	c := make(chan T)

	go func() {
		for _, it := range iter {
			for _, v := range it {
				c <- v
			}
		}
		close(c)
	}()
	return c
}

func ChainFromIterable[T any](iter []<-chan T) chan T {
	return Chain(iter...)
}

func ChainFromIterableS[T any](iter [][]T) chan T {
	return ChainS(iter...)
}

func Compress[T any](data <-chan T, selectors <-chan bool) chan T {
	c := make(chan T)

	go func() {
		z := Zip2(data, selectors)
		for v := range z {
			if v.V2 {
				c <- v.V1
			}
		}
		close(c)
	}()
	return c
}

func CompressS[T any](data []T, selectors []bool) chan T {
	c := make(chan T)

	go func() {
		z := Zip2S(data, selectors)
		for v := range z {
			if v.V2 {
				c <- v.V1
			}
		}
		close(c)
	}()
	return c
}

func DropWhile[T any](pred func(v T) bool, seq <-chan T) chan T {
	c := make(chan T)
	drop := true

	go func() {
		for v := range seq {
			if drop && !pred(v) {
				drop = false
			}
			if !drop {
				c <- v
			}
		}
		close(c)
	}()

	return c
}

func DropWhileS[T any](pred func(v T) bool, seq []T) chan T {
	c := make(chan T)

	go func() {
		start := 0
		for start = range seq {
			if !pred(seq[start]) {
				break
			}
		}

		for i := start; i < len(seq); i++ {
			c <- seq[i]
		}
		close(c)
	}()

	return c
}

func TakeWhile[T any](pred func(v T) bool, seq <-chan T) chan T {
	c := make(chan T)

	go func() {
		for v := range seq {
			if !pred(v) {
				break
			}
			c <- v
		}
		close(c)
	}()

	return c
}

func TakeWhileS[T any](pred func(v T) bool, seq []T) chan T {
	c := make(chan T)

	go func() {
		for i := 0; i < len(seq); i++ {
			if !pred(seq[i]) {
				break
			}

			c <- seq[i]
		}
		close(c)
	}()

	return c
}

func FilterFalse[T any](pred func(v T) bool, seq []T) chan T {
	c := make(chan T)

	go func() {
		for i := range seq {
			if pred(seq[i]) {
				c <- seq[i]
			}
		}
		close(c)
	}()

	return c
}

type Group[T any] struct {
	Key   T
	Group <-chan T
}

func GroupBy[T Comparable](seq []T) chan Group[T] {
	c := make(chan Group[T])
	var gc chan T

	go func() {
		defer func() {
			close(c)
			if gc != nil {
				close(gc)
			}
		}()

		if len(seq) == 0 {
			return
		}

		var curKey T

		for i := range seq {
			if i == 0 || curKey != seq[i] {
				if gc != nil {
					close(gc)
				}

				curKey = seq[i]
				gc = make(chan T)
				c <- Group[T]{
					Key:   curKey,
					Group: gc,
				}
			}

			gc <- seq[i]
		}
	}()

	return c
}

func GroupByIface[T ComparableIface[T]](seq []T) chan Group[T] {
	c := make(chan Group[T])
	var gc chan T

	go func() {
		defer func() {
			close(c)
			if gc != nil {
				close(gc)
			}
		}()

		if len(seq) == 0 {
			return
		}

		var curKey T

		for i := range seq {
			if i == 0 || !curKey.Eq(seq[i]) {
				if gc != nil {
					close(gc)
				}

				curKey = seq[i]
				gc = make(chan T)
				c <- Group[T]{
					Key:   curKey,
					Group: gc,
				}
			}

			gc <- seq[i]
		}
	}()

	return c
}

func ISlice[T any](seq []T, start, stop, step int) chan T {
	if step <= 0 {
		panic("step must be more than zero")
	}

	c := make(chan T)

	go func() {
		defer close(c)

		if stop == 0 {
			stop = len(seq)
		}

		for i := start; i < stop; i += step {
			c <- seq[i]
		}
	}()

	return c
}

func Tee[T any](seq []T, n int) []chan T {
	var cs []chan T

	for i := 0; i < n; i++ {
		c := make(chan T)
		cs = append(cs, c)

		go func() {
			for j := 0; j < len(seq); j++ {
				c <- seq[j]
			}
			close(c)
		}()
	}

	return cs
}

func ZipLongest2[T1, T2 any](s1 []T1, s2 []T2, f1 T1, f2 T2) chan Tuple2[T1, T2] {
	c := make(chan Tuple2[T1, T2])
	l := IntMax(len(s1), len(s2))

	go func() {
		for i := 0; i < l; i++ {
			var v1 T1
			var v2 T2

			if i < len(s1) {
				v1 = s1[i]
			} else {
				v1 = f1
			}

			if i < len(s2) {
				v2 = s2[i]
			} else {
				v2 = f2
			}

			c <- Tuple2[T1, T2]{V1: v1, V2: v2}
		}
		close(c)
	}()

	return c
}

func ZipLongest3[T1, T2, T3 any](s1 []T1, s2 []T2, s3 []T3, f1 T1, f2 T2, f3 T3) chan Tuple3[T1, T2, T3] {
	c := make(chan Tuple3[T1, T2, T3])
	l := IntMax(len(s1), len(s2), len(s3))

	go func() {
		for i := 0; i < l; i++ {
			var v1 T1
			var v2 T2
			var v3 T3

			if i < len(s1) {
				v1 = s1[i]
			} else {
				v1 = f1
			}

			if i < len(s2) {
				v2 = s2[i]
			} else {
				v2 = f2
			}

			if i < len(s3) {
				v3 = s3[i]
			} else {
				v3 = f3
			}

			c <- Tuple3[T1, T2, T3]{V1: v1, V2: v2, V3: v3}
		}
		close(c)
	}()

	return c
}

func ZipLongest4[T1, T2, T3, T4 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, f1 T1, f2 T2, f3 T3, f4 T4) chan Tuple4[T1, T2, T3, T4] {
	c := make(chan Tuple4[T1, T2, T3, T4])
	l := IntMax(len(s1), len(s2), len(s3), len(s4))

	go func() {
		for i := 0; i < l; i++ {
			var v1 T1
			var v2 T2
			var v3 T3
			var v4 T4

			if i < len(s1) {
				v1 = s1[i]
			} else {
				v1 = f1
			}

			if i < len(s2) {
				v2 = s2[i]
			} else {
				v2 = f2
			}

			if i < len(s3) {
				v3 = s3[i]
			} else {
				v3 = f3
			}

			if i < len(s4) {
				v4 = s4[i]
			} else {
				v4 = f4
			}

			c <- Tuple4[T1, T2, T3, T4]{V1: v1, V2: v2, V3: v3, V4: v4}
		}
		close(c)
	}()

	return c
}
