// finite: Iterators terminating on the shortest input sequence

package itertools

func Accumulate[T Addable](iter <-chan T) chan T {
	c := make(chan T)
	var accum T

	go func() {
		for v := range iter {
			accum += v
			c <- accum
		}
		close(c)
	}()
	return c
}

func AccumulateS[T Addable](iter []T) chan T {
	c := make(chan T)
	var accum T

	go func() {
		for _, v := range iter {
			accum += v
			c <- accum
		}
		close(c)
	}()
	return c
}

func AccumulateIface[T AddableIface[T]](iter <- chan T) chan T {
	c := make(chan T)
	var accum T

	go func() {
		for v := range iter {
			accum = accum.Add(v)
			c <- accum
		}
		close(c)
	}()
	return c
}

func AccumulateIfaceS[T AddableIface[T]](iter []T) chan T {
	c := make(chan T)
	var accum T

	go func() {
		for _, v := range iter {
			accum = accum.Add(v)
			c <- accum
		}
		close(c)
	}()
	return c
}

func Chain[T any](iter ...<-chan T) chan T {
	c := make(chan T)

	go func() {
		for _, it := range iter {
			for v := range it {
				c <- v
			}
		}
		close(c)
	}()
	return c
}

func ChainS[T any](iter ...[]T) chan T {
	c := make(chan T)

	go func() {
		for _, it := range iter {
			for _, v := range it {
				c <- v
			}
		}
		close(c)
	}()
	return c
}

func ChainFromIterable[T any](iter []<-chan T) chan T {
	return Chain(iter...)
}

func ChainFromIterableS[T any](iter [][]T) chan T {
	return ChainS(iter...)
}

func Compress[T any](data <-chan T, selectors <-chan bool) chan T {
	c := make(chan T)

	go func() {
		z := Zip2(data, selectors)
		for v := range z {
			if v.V2 {
				c <- v.V1
			}
		}
		close(c)
	}()
	return c
}

func CompressS[T any](data []T, selectors []bool) chan T {
	c := make(chan T)

	go func() {
		z := Zip2S(data, selectors)
		for v := range z {
			if v.V2 {
				c <- v.V1
			}
		}
		close(c)
	}()
	return c
}

func DropWhile[T any](pred func(v T) bool, seq <-chan T) chan T {
	c := make(chan T)
	drop := true

	go func() {
		for v := range seq {
			if drop && !pred(v) {
				drop = false
			}
			if !drop {
				c <- v
			}
		}
		close(c)
	}()

	return c
}

func DropWhileS[T any](pred func(v T) bool, seq []T) chan T {
	c := make(chan T)

	go func() {
		start := 0
		for start = range seq {
			if !pred(seq[start]) {
				break
			}
		}

		for i := start; i < len(seq); i++ {
			c <- seq[i]
		}
		close(c)
	}()

	return c
}

func TakeWhile[T any](pred func(v T) bool, seq <-chan T) chan T {
	c := make(chan T)

	go func() {
		for v := range seq {
			if !pred(v) {
				break
			}
			c <- v
		}
		close(c)
	}()

	return c
}

func TakeWhileS[T any](pred func(v T) bool, seq []T) chan T {
	c := make(chan T)

	go func() {
		for i := 0; i < len(seq); i++ {
			if !pred(seq[i]) {
				break
			}

			c <- seq[i]
		}
		close(c)
	}()

	return c
}

func FilterFalse[T any](pred func(v T) bool, seq <-chan T) <-chan T {
	return Filter(func(v T)bool{ return !pred(v)}, seq)
}

func FilterFalseS[T any](pred func(v T) bool, seq []T) <-chan T {
	return FilterS(func(v T)bool{ return !pred(v)}, seq)
}

type Group[T any] struct {
	Key   T
	Group <-chan T
}

func GroupBy[T Comparable](seq <-chan T) chan Group[T] {
	c := make(chan Group[T])
	var gc chan T

	go func() {
		defer func() {
			close(c)
			if gc != nil {
				close(gc)
			}
		}()

		var curKey T
		var i int

		for v := range seq {
			if i == 0 || curKey != v {
				if gc != nil {
					close(gc)
				}

				curKey = v
				gc = make(chan T)
				c <- Group[T]{
					Key:   curKey,
					Group: gc,
				}
			}

			gc <- v
			i++
		}
	}()

	return c
}

func GroupByS[T Comparable](seq []T) chan Group[T] {
	c := make(chan Group[T])
	var gc chan T

	go func() {
		defer func() {
			close(c)
			if gc != nil {
				close(gc)
			}
		}()

		if len(seq) == 0 {
			return
		}

		var curKey T

		for i := range seq {
			if i == 0 || curKey != seq[i] {
				if gc != nil {
					close(gc)
				}

				curKey = seq[i]
				gc = make(chan T)
				c <- Group[T]{
					Key:   curKey,
					Group: gc,
				}
			}

			gc <- seq[i]
		}
	}()

	return c
}

func GroupByIface[T ComparableIface[T]](seq <-chan T) chan Group[T] {
	c := make(chan Group[T])
	var gc chan T

	go func() {
		defer func() {
			close(c)
			if gc != nil {
				close(gc)
			}
		}()

		var curKey T
		var i int

		for v := range seq {
			if i == 0 || !curKey.Eq(v) {
				if gc != nil {
					close(gc)
				}

				curKey = v
				gc = make(chan T)
				c <- Group[T]{
					Key:   curKey,
					Group: gc,
				}
			}

			gc <- v
			i++
		}
	}()

	return c
}

func GroupByIfaceS[T ComparableIface[T]](seq []T) chan Group[T] {
	c := make(chan Group[T])
	var gc chan T

	go func() {
		defer func() {
			close(c)
			if gc != nil {
				close(gc)
			}
		}()

		if len(seq) == 0 {
			return
		}

		var curKey T

		for i := range seq {
			if i == 0 || !curKey.Eq(seq[i]) {
				if gc != nil {
					close(gc)
				}

				curKey = seq[i]
				gc = make(chan T)
				c <- Group[T]{
					Key:   curKey,
					Group: gc,
				}
			}

			gc <- seq[i]
		}
	}()

	return c
}

func ISlice[T any](seq <-chan T, start, stop, step int) chan T {
	if step <= 0 {
		panic("step must be more than zero")
	}

	c := make(chan T)

	go func() {
		defer close(c)

		var i int

		for v := range seq {
			if i != 0 && i == stop {
				return
			}

			if i >= start && i % step == 0 {
				c <- v
			}
			i++
		}
	}()

	return c
}

func ISliceS[T any](seq []T, start, stop, step int) chan T {
	if step <= 0 {
		panic("step must be more than zero")
	}

	c := make(chan T)

	go func() {
		defer close(c)

		if stop == 0 {
			stop = len(seq)
		}

		for i := start; i < stop; i += step {
			c <- seq[i]
		}
	}()

	return c
}

func Tee[T any](seq <-chan T, n int) []<-chan T {
	// Tee creates N copies of passed channel.
	//
	// CAUTION and FIXME: the incoming channel that is shared among
	// all tee'd channels will advance after ALL tee'd channels
	// consume the current value.
	//
	// Let's say there are three channels. Namely:
	// - C: the original channel
	// - T1: 1st tee'd copy of C
	// - T2: 2nd tee'd copy of C
	//
	// 1. Goroutine A consumes T1.
	// 2. Goro B is too busy to consume T2 for now.
	// 3. Goro A tries to consume the next value via T1 but it blocks.
	//    It's because C won't advance until goro B consumes T2.
	//
	// This will be fixed after we implement a generic buffer.

	var cs []chan T

	for i := 0; i < n; i++ {
		cs = append(cs, make(chan T))
	}

	go func() {
		defer func() {
			for i := range cs {
				close(cs[i])
			}
		}()

		for v := range seq {
			for i := range cs {
				cs[i] <- v
			}
		}
	}()

	var csr []<-chan T
	for i := range cs {
		csr = append(csr, cs[i])
	}

	return csr
}

func TeeS[T any](seq []T, n int) []<-chan T {
	var cs []chan T

	for i := 0; i < n; i++ {
		cs = append(cs, make(chan T))
	}

	go func() {
		defer func() {
			for i := range cs {
				close(cs[i])
			}
		}()

		for i := range seq {
			for j := range cs {
				cs[j] <- seq[i]
			}
		}
	}()

	var csr []<-chan T
	for i := range cs {
		csr = append(csr, cs[i])
	}

	return csr
}

func ZipLongest2[T1, T2 any](it1 <-chan T1, it2 <-chan T2, f1 T1, f2 T2) chan Tuple2[T1, T2] {
	return zip2(it1, it2, f1, f2, true)
}

func ZipLongest2S[T1, T2 any](s1 []T1, s2 []T2, f1 T1, f2 T2) chan Tuple2[T1, T2] {
	c := make(chan Tuple2[T1, T2])
	l := Max(len(s1), len(s2))

	go func() {
		for i := 0; i < l; i++ {
			var v1 T1
			var v2 T2

			if i < len(s1) {
				v1 = s1[i]
			} else {
				v1 = f1
			}

			if i < len(s2) {
				v2 = s2[i]
			} else {
				v2 = f2
			}

			c <- Tuple2[T1, T2]{V1: v1, V2: v2}
		}
		close(c)
	}()

	return c
}

func ZipLongest3[T1, T2, T3 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, f1 T1, f2 T2, f3 T3) chan Tuple3[T1, T2, T3] {
	return zip3(it1, it2, it3, f1, f2, f3, true)
}

func ZipLongest3S[T1, T2, T3 any](s1 []T1, s2 []T2, s3 []T3, f1 T1, f2 T2, f3 T3) chan Tuple3[T1, T2, T3] {
	c := make(chan Tuple3[T1, T2, T3])
	l := Max(len(s1), len(s2), len(s3))

	go func() {
		for i := 0; i < l; i++ {
			var v1 T1
			var v2 T2
			var v3 T3

			if i < len(s1) {
				v1 = s1[i]
			} else {
				v1 = f1
			}

			if i < len(s2) {
				v2 = s2[i]
			} else {
				v2 = f2
			}

			if i < len(s3) {
				v3 = s3[i]
			} else {
				v3 = f3
			}

			c <- Tuple3[T1, T2, T3]{V1: v1, V2: v2, V3: v3}
		}
		close(c)
	}()

	return c
}

func ZipLongest4[T1, T2, T3, T4 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, it4 <-chan T4, f1 T1, f2 T2, f3 T3, f4 T4) chan Tuple4[T1, T2, T3, T4] {
	return zip4(it1, it2, it3, it4, f1, f2, f3, f4, true)
}

func ZipLongest4S[T1, T2, T3, T4 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, f1 T1, f2 T2, f3 T3, f4 T4) chan Tuple4[T1, T2, T3, T4] {
	c := make(chan Tuple4[T1, T2, T3, T4])
	l := Max(len(s1), len(s2), len(s3), len(s4))

	go func() {
		for i := 0; i < l; i++ {
			var v1 T1
			var v2 T2
			var v3 T3
			var v4 T4

			if i < len(s1) {
				v1 = s1[i]
			} else {
				v1 = f1
			}

			if i < len(s2) {
				v2 = s2[i]
			} else {
				v2 = f2
			}

			if i < len(s3) {
				v3 = s3[i]
			} else {
				v3 = f3
			}

			if i < len(s4) {
				v4 = s4[i]
			} else {
				v4 = f4
			}

			c <- Tuple4[T1, T2, T3, T4]{V1: v1, V2: v2, V3: v3, V4: v4}
		}
		close(c)
	}()

	return c
}
