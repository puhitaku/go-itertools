// finite: Iterators terminating on the shortest input sequence

package itertools

func Accumulate[T Addable](iter []T) []T {
	var s []T
	var accum T

	for i := range iter {
		accum += iter[i]
		s = append(s, accum)
	}

	return s
}

func AccumulateC[T Addable](iter <-chan T) chan T {
	c := make(chan T)
	var accum T

	go func() {
		for v := range iter {
			accum += v
			c <- accum
		}
		close(c)
	}()
	return c
}

func AccumulateIface[T AddableIface[T]](iter []T) []T {
	var s []T
	var accum T

	for i := range iter {
		accum = accum.Add(iter[i])
		s = append(s, accum)
	}

	return s
}

func AccumulateIfaceC[T AddableIface[T]](iter <- chan T) chan T {
	c := make(chan T)
	var accum T

	go func() {
		for v := range iter {
			accum = accum.Add(v)
			c <- accum
		}
		close(c)
	}()
	return c
}

func Chain[T any](iter ...[]T) []T {
	var s []T

	for i := range iter {
		for j := range iter[i] {
			s = append(s, iter[i][j])
		}
	}

	return s
}

func ChainC[T any](iter ...<-chan T) chan T {
	c := make(chan T)

	go func() {
		for _, it := range iter {
			for v := range it {
				c <- v
			}
		}
		close(c)
	}()

	return c
}

func ChainFromIterable[T any](iter [][]T) []T {
	return Chain(iter...)
}

func ChainFromIterableC[T any](iter []<-chan T) chan T {
	return ChainC(iter...)
}

func Compress[T any](data []T, selectors []bool) []T {
	var s []T

	z := Zip2(data, selectors)
	for i := range z {
		if z[i].V2 {
			s = append(s, z[i].V1)
		}
	}

	return s
}

func CompressC[T any](data <-chan T, selectors <-chan bool) chan T {
	c := make(chan T)

	go func() {
		z := Zip2C(data, selectors)
		for v := range z {
			if v.V2 {
				c <- v.V1
			}
		}
		close(c)
	}()
	return c
}

func DropWhile[T any](pred func(v T) bool, seq []T) []T {
	start := 0
	for start = range seq {
		if !pred(seq[start]) {
			break
		}
	}

	return seq[start:]
}

func DropWhileC[T any](pred func(v T) bool, seq <-chan T) chan T {
	c := make(chan T)
	drop := true

	go func() {
		for v := range seq {
			if drop && !pred(v) {
				drop = false
			}
			if !drop {
				c <- v
			}
		}
		close(c)
	}()

	return c
}

func TakeWhile[T any](pred func(v T) bool, seq []T) []T {
	stop := 0
	for stop = range seq {
		if !pred(seq[stop]) {
			break
		}
	}
	return seq[:stop]
}

func TakeWhileC[T any](pred func(v T) bool, seq <-chan T) chan T {
	c := make(chan T)

	go func() {
		for v := range seq {
			if !pred(v) {
				break
			}
			c <- v
		}
		close(c)
	}()

	return c
}

func FilterFalse[T any](pred func(v T) bool, seq []T) []T {
	return Filter(func(v T)bool{ return !pred(v)}, seq)
}

func FilterFalseC[T any](pred func(v T) bool, seq <-chan T) <-chan T {
	return FilterC(func(v T)bool{ return !pred(v)}, seq)
}

type Group[T any] struct {
	Key   T
	Group []T
}

type GroupC[T any] struct {
	Key   T
	Group <-chan T
}

func GroupBy[T Comparable](seq []T) []Group[T] {
	var s []Group[T]

	if len(seq) == 0 {
		return []Group[T]{}
	}

	var curKey T

	for i := range seq {
		if i == 0 || curKey != seq[i] {
			curKey = seq[i]
			s = append(
				s,
				Group[T]{
					Key:   curKey,
					Group: []T{},
				},
			)
		}

		s[len(s)-1].Group = append(s[len(s)-1].Group, seq[i])
	}

	return s
}

func GroupByC[T Comparable](seq <-chan T) chan GroupC[T] {
	c := make(chan GroupC[T])
	var gc chan T

	go func() {
		defer func() {
			close(c)
			if gc != nil {
				close(gc)
			}
		}()

		var curKey T
		var i int

		for v := range seq {
			if i == 0 || curKey != v {
				if gc != nil {
					close(gc)
				}

				curKey = v
				gc = make(chan T)
				c <- GroupC[T]{
					Key:   curKey,
					Group: gc,
				}
			}

			gc <- v
			i++
		}
	}()

	return c
}

func GroupByIface[T ComparableIface[T]](seq []T) []Group[T] {
	var s []Group[T]

	if len(seq) == 0 {
		return []Group[T]{}
	}

	var curKey T

	for i := range seq {
		if i == 0 || !curKey.Eq(seq[i]) {
			curKey = seq[i]
			s = append(
				s,
				Group[T]{
					Key:   curKey,
					Group: []T{},
				},
			)
		}

		s[len(s)-1].Group = append(s[len(s)-1].Group, seq[i])
	}

	return s
}

func GroupByIfaceC[T ComparableIface[T]](seq <-chan T) chan GroupC[T] {
	c := make(chan GroupC[T])
	var gc chan T

	go func() {
		defer func() {
			close(c)
			if gc != nil {
				close(gc)
			}
		}()

		var curKey T
		var i int

		for v := range seq {
			if i == 0 || !curKey.Eq(v) {
				if gc != nil {
					close(gc)
				}

				curKey = v
				gc = make(chan T)
				c <- GroupC[T]{
					Key:   curKey,
					Group: gc,
				}
			}

			gc <- v
			i++
		}
	}()

	return c
}

func ISlice[T any](seq []T, start, stop, step int) []T {
	if step <= 0 {
		panic("step must be more than zero")
	}

	var s []T

	if stop == 0 {
		stop = len(seq)
	}

	for i := start; i < stop; i += step {
		s = append(s, seq[i])
	}

	return s
}

func ISliceC[T any](seq <-chan T, start, stop, step int) chan T {
	if step <= 0 {
		panic("step must be more than zero")
	}

	c := make(chan T)

	go func() {
		defer close(c)

		var i int

		for v := range seq {
			if i != 0 && i == stop {
				return
			}

			if i >= start && i % step == 0 {
				c <- v
			}
			i++
		}
	}()

	return c
}

func Tee[T any](seq []T, n int) [][]T {
	// Tee create N copies of passed slice.
	// Perhaps it's not a true "tee-ing" tho.

	var ss [][]T

	for i := 0; i < n; i++ {
		ss = append(ss, make([]T, len(seq)))
		copy(ss[len(ss)-1], seq)
	}

	return ss
}

func TeeC[T any](seq <-chan T, n int) []<-chan T {
	// TeeC creates N copies of passed channel.
	//
	// CAUTION and FIXME: the incoming channel that is shared among
	// all tee'd channels will advance after ALL tee'd channels
	// consume the current value.
	//
	// Let's say there are three channels. Namely:
	// - C: the original channel
	// - T1: 1st tee'd copy of C
	// - T2: 2nd tee'd copy of C
	//
	// 1. Goroutine A consumes T1.
	// 2. Goro B is too busy to consume T2 for now.
	// 3. Goro A tries to consume the next value via T1 but it blocks.
	//    It's because C won't advance until goro B consumes T2.
	//
	// This will be fixed after we implement a generic buffer.

	var cs []chan T

	for i := 0; i < n; i++ {
		cs = append(cs, make(chan T))
	}

	go func() {
		defer func() {
			for i := range cs {
				close(cs[i])
			}
		}()

		for v := range seq {
			for i := range cs {
				cs[i] <- v
			}
		}
	}()

	var csr []<-chan T
	for i := range cs {
		csr = append(csr, cs[i])
	}

	return csr
}

func ZipLongest2[T1, T2 any](s1 []T1, s2 []T2, f1 T1, f2 T2) []Tuple2[T1, T2] {
	var s []Tuple2[T1, T2]
	l := Max(len(s1), len(s2))

	for i := 0; i < l; i++ {
		var v1 T1
		var v2 T2

		if i < len(s1) {
			v1 = s1[i]
		} else {
			v1 = f1
		}

		if i < len(s2) {
			v2 = s2[i]
		} else {
			v2 = f2
		}

		s = append(s, Tuple2[T1, T2]{V1: v1, V2: v2})
	}

	return s
}

func ZipLongest2C[T1, T2 any](it1 <-chan T1, it2 <-chan T2, f1 T1, f2 T2) chan Tuple2[T1, T2] {
	return zip2c(it1, it2, f1, f2, true)
}

func ZipLongest3[T1, T2, T3 any](s1 []T1, s2 []T2, s3 []T3, f1 T1, f2 T2, f3 T3) []Tuple3[T1, T2, T3] {
	var s []Tuple3[T1, T2, T3]
	l := Max(len(s1), len(s2), len(s3))

	for i := 0; i < l; i++ {
		var v1 T1
		var v2 T2
		var v3 T3

		if i < len(s1) {
			v1 = s1[i]
		} else {
			v1 = f1
		}

		if i < len(s2) {
			v2 = s2[i]
		} else {
			v2 = f2
		}

		if i < len(s3) {
			v3 = s3[i]
		} else {
			v3 = f3
		}

		s = append(s, Tuple3[T1, T2, T3]{V1: v1, V2: v2, V3: v3})
	}

	return s
}

func ZipLongest3C[T1, T2, T3 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, f1 T1, f2 T2, f3 T3) chan Tuple3[T1, T2, T3] {
	return zip3c(it1, it2, it3, f1, f2, f3, true)
}

func ZipLongest4[T1, T2, T3, T4 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, f1 T1, f2 T2, f3 T3, f4 T4) []Tuple4[T1, T2, T3, T4] {
	var s []Tuple4[T1, T2, T3, T4]
	l := Max(len(s1), len(s2), len(s3), len(s4))

	for i := 0; i < l; i++ {
		var v1 T1
		var v2 T2
		var v3 T3
		var v4 T4

		if i < len(s1) {
			v1 = s1[i]
		} else {
			v1 = f1
		}

		if i < len(s2) {
			v2 = s2[i]
		} else {
			v2 = f2
		}

		if i < len(s3) {
			v3 = s3[i]
		} else {
			v3 = f3
		}

		if i < len(s4) {
			v4 = s4[i]
		} else {
			v4 = f4
		}

		s = append(s, Tuple4[T1, T2, T3, T4]{V1: v1, V2: v2, V3: v3, V4: v4})
	}

	return s
}

func ZipLongest4C[T1, T2, T3, T4 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, it4 <-chan T4, f1 T1, f2 T2, f3 T3, f4 T4) chan Tuple4[T1, T2, T3, T4] {
	return zip4c(it1, it2, it3, it4, f1, f2, f3, f4, true)
}
