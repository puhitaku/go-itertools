// builtins: Ported Python builtins

package itertools

import (
	"sort"
)

func IntMin(i ...int) int {
	if len(i) < 1 {
		panic("no comparable integers are passed")
	}

	sort.Ints(i)
	return i[0]
}

func IntMax(i ...int) int {
	if len(i) < 1 {
		panic("no comparable integers are passed")
	}

	sort.Ints(i)
	return i[len(i)-1]
}

func Zip2[T1, T2 any](it1 <-chan T1, it2 <-chan T2) chan Tuple2[T1, T2] {
	c := make(chan Tuple2[T1, T2])

	go func() {
		defer close(c)

		var v1 T1
		var v2 T2
		var ok bool

		for {
			select {
			case v1, ok = <-it1:
				if !ok {
					return
				}
				v2, ok = <-it2
				if !ok {
					return
				}

			case v2, ok = <-it2:
				if !ok {
					return
				}
				v1, ok = <-it1
				if !ok {
					return
				}
			}
			c <- Tuple2[T1, T2]{V1: v1, V2: v2}
		}
	}()

	return c
}

func Zip2S[T1, T2 any](it1 []T1, it2 []T2) chan Tuple2[T1, T2] {
	c := make(chan Tuple2[T1, T2])
	l := IntMin(len(it1), len(it2))

	go func() {
		for i := 0; i < l; i++ {
			c <- Tuple2[T1, T2]{V1: it1[i], V2: it2[i]}
		}
		close(c)
	}()

	return c
}

func Zip3[T1, T2, T3 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3) chan Tuple3[T1, T2, T3] {
	c := make(chan Tuple3[T1, T2, T3])

	go func() {
		defer close(c)

		var v1 T1
		var v2 T2
		var v3 T3
		var ok bool

		for {
			select {
			case v1, ok = <-it1:
				if !ok {
					return
				}
				select {
				case v2, ok = <-it2:
					if !ok {
						return
					}
					v3, ok = <-it3
					if !ok {
						return
					}
				case v3, ok = <-it3:
					if !ok {
						return
					}
					v2, ok = <-it2
					if !ok {
						return
					}
				}
			case v2, ok = <-it2:
				if !ok {
					return
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						return
					}
					v3, ok = <-it3
					if !ok {
						return
					}
				case v3, ok = <-it3:
					if !ok {
						return
					}
					v1, ok = <-it1
					if !ok {
						return
					}
				}
			case v3, ok = <-it3:
				if !ok {
					return
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						return
					}
					v2, ok = <-it2
					if !ok {
						return
					}
				case v2, ok = <-it2:
					if !ok {
						return
					}
					v1, ok = <-it1
					if !ok {
						return
					}
				}
			}

			c <- Tuple3[T1, T2, T3]{V1: v1, V2: v2, V3: v3}
		}
	}()

	return c
}

func Zip3S[T1, T2, T3 any](it1 []T1, it2 []T2, it3 []T3) chan Tuple3[T1, T2, T3] {
	c := make(chan Tuple3[T1, T2, T3])
	l := IntMin(len(it1), len(it2), len(it3))

	go func() {
		for i := 0; i < l; i++ {
			c <- Tuple3[T1, T2, T3]{V1: it1[i], V2: it2[i], V3: it3[i]}
		}
		close(c)
	}()

	return c
}

func Zip4[T1, T2, T3, T4 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, it4 <-chan T4) chan Tuple4[T1, T2, T3, T4] {
	c := make(chan Tuple4[T1, T2, T3, T4])

	go func() {
		defer close(c)

		var v1 T1
		var v2 T2
		var v3 T3
		var v4 T4
		var ok bool

		for {
			select {
			case v1, ok = <-it1:
				if !ok {
					return
				}
				select {
				case v2, ok = <-it2:
					if !ok {
						return
					}
					select {
					case v3, ok = <-it3:
						if !ok {
							return
						}
						v4, ok = <-it4
						if !ok {
							return
						}
					case v4, ok = <-it4:
						if !ok {
							return
						}
						v3, ok = <-it3
						if !ok {
							return
						}
					}
				case v3, ok = <-it3:
					if !ok {
						return
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							return
						}
						v4, ok = <-it4
						if !ok {
							return
						}
					case v4, ok = <-it4:
						if !ok {
							return
						}
						v2, ok = <-it2
						if !ok {
							return
						}
					}
				case v4, ok = <-it4:
					if !ok {
						return
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							return
						}
						v3, ok = <-it3
						if !ok {
							return
						}
					case v3, ok = <-it3:
						if !ok {
							return
						}
						v2, ok = <-it2
						if !ok {
							return
						}
					}
				}
			case v2, ok = <-it2:
				if !ok {
					return
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						return
					}
					select {
					case v3, ok = <-it3:
						if !ok {
							return
						}
						v4, ok = <-it4
						if !ok {
							return
						}
					case v4, ok = <-it4:
						if !ok {
							return
						}
						v3, ok = <-it3
						if !ok {
							return
						}
					}
				case v3, ok = <-it3:
					if !ok {
						return
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							return
						}
						v4, ok = <-it4
						if !ok {
							return
						}
					case v4, ok = <-it4:
						if !ok {
							return
						}
						v1, ok = <-it1
						if !ok {
							return
						}
					}
				case v4, ok = <-it4:
					if !ok {
						return
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							return
						}
						v3, ok = <-it3
						if !ok {
							return
						}
					case v3, ok = <-it3:
						if !ok {
							return
						}
						v1, ok = <-it1
						if !ok {
							return
						}
					}
				}
			case v3, ok = <-it3:
				if !ok {
					return
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						return
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							return
						}
						v4, ok = <-it4
						if !ok {
							return
						}
					case v4, ok = <-it4:
						if !ok {
							return
						}
						v2, ok = <-it2
						if !ok {
							return
						}
					}
				case v2, ok = <-it2:
					if !ok {
						return
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							return
						}
						v4, ok = <-it4
						if !ok {
							return
						}
					case v4, ok = <-it4:
						if !ok {
							return
						}
						v1, ok = <-it1
						if !ok {
							return
						}
					}
				case v4, ok = <-it4:
					if !ok {
						return
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							return
						}
						v2, ok = <-it2
						if !ok {
							return
						}
					case v2, ok = <-it2:
						if !ok {
							return
						}
						v1, ok = <-it1
						if !ok {
							return
						}
					}
				}
			case v4, ok = <-it4:
				if !ok {
					return
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						return
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							return
						}
						v3, ok = <-it3
						if !ok {
							return
						}
					case v3, ok = <-it3:
						if !ok {
							return
						}
						v2, ok = <-it2
						if !ok {
							return
						}
					}
				case v2, ok = <-it2:
					if !ok {
						return
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							return
						}
						v3, ok = <-it3
						if !ok {
							return
						}
					case v3, ok = <-it3:
						if !ok {
							return
						}
						v1, ok = <-it1
						if !ok {
							return
						}
					}
				case v3, ok = <-it3:
					if !ok {
						return
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							return
						}
						v2, ok = <-it2
						if !ok {
							return
						}
					case v2, ok = <-it2:
						if !ok {
							return
						}
						v1, ok = <-it1
						if !ok {
							return
						}
					}
				}
			}

			c <- Tuple4[T1, T2, T3, T4]{V1: v1, V2: v2, V3: v3, V4: v4}
		}
	}()

	return c
}



func Zip4S[T1, T2, T3, T4 any](it1 []T1, it2 []T2, it3 []T3, it4 []T4) chan Tuple4[T1, T2, T3, T4] {
	c := make(chan Tuple4[T1, T2, T3, T4])
	l := IntMin(len(it1), len(it2), len(it3), len(it4))

	go func() {
		for i := 0; i < l; i++ {
			c <- Tuple4[T1, T2, T3, T4]{V1: it1[i], V2: it2[i], V3: it3[i], V4: it4[i]}
		}
		close(c)
	}()

	return c
}
