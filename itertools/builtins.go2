// builtins: A collection of ported Python builtins that are related to iterables

package itertools

import (
	"sort"
)

func All(it []bool) bool {
	for i := range it {
		if !it[i] {
			return false
		}
	}
	return true
}

func Any(it []bool) bool {
	for i := range it {
		if it[i] {
			return true
		}
	}
	return false
}

func EnumerateC[T any](it <-chan T) <-chan Tuple2[int, T] {
	// Enumerate enumerate the received values from channel.
	// Use this when you handle infinite, too huge, or unpredictable channels.
	// For slices, you'd better use the native way; `for i, v := range s { ... }`

	c := make(chan Tuple2[int, T])

	go func() {
		defer close(c)
		i := 0
		for v := range it {
			c <- Tuple2[int, T]{V1: i, V2: v}
			i++
		}
	}()

	return c
}

func Filter[T any](fn func(v T) bool, it []T) []T {
	var s []T

	for i := range it {
		if fn(it[i]) {
			s = append(s, it[i])
		}
	}

	return s
}

func FilterC[T any](fn func(v T) bool, it <-chan T) <-chan T {
	c := make(chan T)

	go func() {
		for v := range it {
			if fn(v) {
				c <- v
			}
		}
		close(c)
	}()

	return c
}

func Map[T1, T2 any](fn func(v T1) T2, it []T1) []T2 {
	var s []T2

	for i := range it {
		s = append(s, fn(it[i]))
	}

	return s
}

func MapC[T1, T2 any](fn func(v T1) T2, it <-chan T1) <-chan T2 {
	c := make(chan T2)

	go func() {
		for v := range it {
			c <- fn(v)
		}
		close(c)
	}()

	return c
}

func copyS[T any](it []T) []T {
	tmp := make([]T, len(it))
	copy(tmp, it)
	return tmp
}

func Min[T Ordered](it ...T) T {
	min := it[0]
	it = it[1:]

	for i := range it {
		if min > it[i] {
			min = it[i]
		}
	}

	return min
}

func MinS[T Ordered](it []T) T {
	if len(it) < 1 {
		panic("the arg is an empty sequence")
	}

	min := it[0]
	it = it[1:]

	for i := range it {
		if min > it[i] {
			min = it[i]
		}
	}

	return min
}

func Max[T Ordered](it ...T) T {
	max := it[0]
	it = it[1:]

	for i := range it {
		if max < it[i] {
			max = it[i]
		}
	}

	return max
}

func MaxS[T Ordered](it []T) T {
	if len(it) == 0 {
		panic("the arg is an empty sequence")
	}

	max := it[0]
	it = it[1:]

	for i := range it {
		if max < it[i] {
			max = it[i]
		}
	}

	return max
}

func Range(start, stop, step int) []int {
	var it []int

	if start < stop {
		if step < 1 {
			return it
		}
		for i := start; i < stop; i += step {
			it = append(it, i)
		}
	} else {
		if step > -1 {
			return it
		}
		for i := start; i > stop; i += step {
			it = append(it, i)
		}
	}

	return it
}

func RangeC(start, stop, step int) <-chan int {
	c := make(chan int)

	go func() {
		defer close(c)

		if start < stop {
			if step < 1 {
				return
			}
			for i := start; i < stop; i += step {
				c <- i
			}
		} else {
			if step > -1 {
				return
			}
			for i := start; i > stop; i += step {
				c <- i
			}
		}
	}()

	return c
}

func Reversed[T any](it []T) []T {
	// Reversed returns a reversed slice.
	// This operation is not in-place.

	var s []T

	for i := range it {
		s = append(s, it[len(it)-1-i])
	}

	return s
}

func ReversedC[T any](it <-chan T) <-chan T {
	// ReversedC is a variation of Reversed.
	// Keep in mind that it won't send anything until the input channel closes.

	c := make(chan T)

	go func() {
		defer close(c)

		var buf []T
		for v := range it {
			buf = append(buf, v)
		}

		for i := range buf {
			c <- buf[len(buf)-1-i]
		}
	}()

	return c
}

func Sorted[T Ordered](it []T) []T {
	tmp := copyS(it)
	sort.Sort(toSortable(tmp))

	return tmp
}

func SortedC[T Ordered](it <-chan T) <-chan T {
	c := make(chan T)

	go func() {
		defer close(c)
		var buf []T

		for v := range it {
			buf = append(buf, v)
		}

		sort.Sort(toSortable(buf))

		for i := range buf {
			c <- buf[i]
		}
	}()

	return c
}

func Sum[T Addable](it []T) T {
	sum := it[0]
	for i := range it[1:] {
		sum += it[i+1]
	}
	return sum
}

func SumC[T Addable](it <-chan T) T {
	var sum T
	for v := range it {
		sum += v
	}
	return sum
}

func SumIface[T AddableIface[T]](it []T) T {
	sum := it[0]
	for i := range it[1:] {
		sum = sum.Add(it[i+1])
	}
	return sum
}

func SumIfaceC[T AddableIface[T]](it <-chan T) T {
	var sum T
	for v := range it {
		sum = sum.Add(v)
	}
	return sum
}

func Zip2[T1, T2 any](it1 []T1, it2 []T2) []Tuple2[T1, T2] {
	var s []Tuple2[T1, T2]
	l := Min(len(it1), len(it2))

	for i := 0; i < l; i++ {
		s = append(s, Tuple2[T1, T2]{V1: it1[i], V2: it2[i]})
	}

	return s
}

func zip2c[T1, T2 any](it1 <-chan T1, it2 <-chan T2, f1 T1, f2 T2, longest bool) chan Tuple2[T1, T2] {
	c := make(chan Tuple2[T1, T2])

	go func() {
		defer close(c)

		var v1 T1
		var v2 T2
		var closed = make([]bool, 2)
		var ok bool

		for {
			select {
			case v1, ok = <-it1:
				if !ok {
					closed[0] = true
				}
				v2, ok = <-it2
				if !ok {
					closed[1] = true
				}

			case v2, ok = <-it2:
				if !ok {
					closed[1] = true
				}
				v1, ok = <-it1
				if !ok {
					closed[0] = true
				}
			}

			if closed[0] || closed[1] {
				if (closed[0] && closed[1]) || !longest {
					return
				}
				if closed[0] {
					v1 = f1
				}
				if closed[1] {
					v2 = f2
				}
			}

			c <- Tuple2[T1, T2]{V1: v1, V2: v2}
		}
	}()

	return c
}

func Zip2C[T1, T2 any](it1 <-chan T1, it2 <-chan T2) chan Tuple2[T1, T2] {
	var dummy1 T1
	var dummy2 T2
	return zip2c(it1, it2, dummy1, dummy2, false)
}

func Zip3[T1, T2, T3 any](it1 []T1, it2 []T2, it3 []T3) []Tuple3[T1, T2, T3] {
	var s []Tuple3[T1, T2, T3]
	l := Min(len(it1), len(it2), len(it3))

	for i := 0; i < l; i++ {
		s = append(s, Tuple3[T1, T2, T3]{V1: it1[i], V2: it2[i], V3: it3[i]})
	}

	return s
}

func zip3c[T1, T2, T3 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, f1 T1, f2 T2, f3 T3, longest bool) chan Tuple3[T1, T2, T3] {
	c := make(chan Tuple3[T1, T2, T3])

	go func() {
		defer close(c)

		var v1 T1
		var v2 T2
		var v3 T3
		var closed = make([]bool, 3)
		var ok bool

		for {
			select {
			case v1, ok = <-it1:
				if !ok {
					closed[0] = true
				}
				select {
				case v2, ok = <-it2:
					if !ok {
						closed[1] = true
					}
					v3, ok = <-it3
					if !ok {
						closed[2] = true
					}
				case v3, ok = <-it3:
					if !ok {
						closed[2] = true
					}
					v2, ok = <-it2
					if !ok {
						closed[1] = true
					}
				}
			case v2, ok = <-it2:
				if !ok {
					closed[1] = true
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						closed[0] = true
					}
					v3, ok = <-it3
					if !ok {
						closed[2] = true
					}
				case v3, ok = <-it3:
					if !ok {
						closed[2] = true
					}
					v1, ok = <-it1
					if !ok {
						closed[0] = true
					}
				}
			case v3, ok = <-it3:
				if !ok {
					closed[2] = true
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						closed[0] = true
					}
					v2, ok = <-it2
					if !ok {
						closed[1] = true
					}
				case v2, ok = <-it2:
					if !ok {
						closed[1] = true
					}
					v1, ok = <-it1
					if !ok {
						closed[0] = true
					}
				}
			}

			if closed[0] || closed[1] || closed[2] {
				if (closed[0] && closed[1] && closed[2]) || !longest {
					return
				}
				if closed[0] {
					v1 = f1
				}
				if closed[1] {
					v2 = f2
				}
				if closed[2] {
					v3 = f3
				}
			}

			c <- Tuple3[T1, T2, T3]{V1: v1, V2: v2, V3: v3}
		}
	}()

	return c
}

func Zip3C[T1, T2, T3 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3) chan Tuple3[T1, T2, T3] {
	var dummy1 T1
	var dummy2 T2
	var dummy3 T3
	return zip3c(it1, it2, it3, dummy1, dummy2, dummy3, false)
}

func Zip4[T1, T2, T3, T4 any](it1 []T1, it2 []T2, it3 []T3, it4 []T4) []Tuple4[T1, T2, T3, T4] {
	var s []Tuple4[T1, T2, T3, T4]
	l := Min(len(it1), len(it2), len(it3), len(it4))

	for i := 0; i < l; i++ {
		s = append(s, Tuple4[T1, T2, T3, T4]{V1: it1[i], V2: it2[i], V3: it3[i], V4: it4[i]})
	}

	return s
}

func zip4c[T1, T2, T3, T4 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, it4 <-chan T4, f1 T1, f2 T2, f3 T3, f4 T4, longest bool) chan Tuple4[T1, T2, T3, T4] {
	c := make(chan Tuple4[T1, T2, T3, T4])

	go func() {
		defer close(c)

		var v1 T1
		var v2 T2
		var v3 T3
		var v4 T4
		var closed = make([]bool, 4)
		var ok bool

		for {
			select {
			case v1, ok = <-it1:
				if !ok {
					closed[0] = true
				}
				select {
				case v2, ok = <-it2:
					if !ok {
						closed[1] = true
					}
					select {
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					}
				case v3, ok = <-it3:
					if !ok {
						closed[2] = true
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					}
				case v4, ok = <-it4:
					if !ok {
						closed[3] = true
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					}
				}
			case v2, ok = <-it2:
				if !ok {
					closed[1] = true
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						closed[0] = true
					}
					select {
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					}
				case v3, ok = <-it3:
					if !ok {
						closed[2] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				case v4, ok = <-it4:
					if !ok {
						closed[3] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				}
			case v3, ok = <-it3:
				if !ok {
					closed[2] = true
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						closed[0] = true
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					}
				case v2, ok = <-it2:
					if !ok {
						closed[1] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				case v4, ok = <-it4:
					if !ok {
						closed[3] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				}
			case v4, ok = <-it4:
				if !ok {
					closed[3] = true
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						closed[0] = true
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					}
				case v2, ok = <-it2:
					if !ok {
						closed[1] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				case v3, ok = <-it3:
					if !ok {
						closed[2] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				}
			}

			if closed[0] || closed[1] || closed[2] || closed[3] {
				if (closed[0] && closed[1] && closed[2] && closed[3]) || !longest {
					return
				}
				if closed[0] {
					v1 = f1
				}
				if closed[1] {
					v2 = f2
				}
				if closed[2] {
					v3 = f3
				}
				if closed[3] {
					v4 = f4
				}
			}

			c <- Tuple4[T1, T2, T3, T4]{V1: v1, V2: v2, V3: v3, V4: v4}
		}
	}()

	return c
}

func Zip4C[T1, T2, T3, T4 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, it4 <-chan T4) chan Tuple4[T1, T2, T3, T4] {
	var dummy1 T1
	var dummy2 T2
	var dummy3 T3
	var dummy4 T4
	return zip4c(it1, it2, it3, it4, dummy1, dummy2, dummy3, dummy4, false)
}
