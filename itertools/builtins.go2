// builtins: A collection of ported Python builtins that are related to iterables

package itertools

import (
	"sort"
)

func All(it []bool) bool {
	for i := range it {
		if !it[i] {
			return false
		}
	}
	return true
}

func Any(it []bool) bool {
	for i := range it {
		if it[i] {
			return true
		}
	}
	return false
}

func Enumerate[T any](it <-chan T) <-chan Tuple2[int, T] {
	// Enumerate enumerate the received values from channel.
	// Use this when you handle infinite, too huge, or unpredictable channels.
	// For slices, you'd better use the native way; `for i, v := range s { ... }`

	c := make(chan Tuple2[int, T])

	go func() {
		defer close(c)
		i := 0
		for v := range it {
			c <- Tuple2[int, T]{V1: i, V2: v}
			i++
		}
	}()

	return c
}

func Filter[T any](fn func(v T) bool, it <-chan T) <-chan T {
	c := make(chan T)

	go func() {
		for v := range it {
			if fn(v) {
				c <- v
			}
		}
		close(c)
	}()

	return c
}

func FilterS[T any](fn func(v T) bool, it []T) <-chan T {
	c := make(chan T)

	go func() {
		for i := range it {
			if fn(it[i]) {
				c <- it[i]
			}
		}
		close(c)
	}()

	return c
}

func Map[T1, T2 any](fn func(v T1) T2, it <-chan T1) <-chan T2 {
	c := make(chan T2)

	go func() {
		for v := range it {
			c <- fn(v)
		}
		close(c)
	}()

	return c
}

func MapS[T1, T2 any](fn func(v T1) T2, it []T1) <-chan T2 {
	c := make(chan T2)

	go func() {
		for i := range it {
			c <- fn(it[i])
		}
		close(c)
	}()

	return c
}

func Min[T Ordered](it ...T) T {
	sort.Sort(toSortable(it))
	return it[0]
}

func MinS[T Ordered](it []T) T {
	if len(it) < 1 {
		panic("the arg is an empty sequence")
	}
	sort.Sort(toSortable(it))
	return it[0]
}

func Max[T Ordered](it ...T) T {
	sort.Sort(toSortable(it))
	return it[len(it)-1]
}

func MaxS[T Ordered](it []T) T {
	if len(it) < 1 {
		panic("the arg is an empty sequence")
	}
	sort.Sort(toSortable(it))
	return it[len(it)-1]
}

func zip2[T1, T2 any](it1 <-chan T1, it2 <-chan T2, f1 T1, f2 T2, longest bool) chan Tuple2[T1, T2] {
	c := make(chan Tuple2[T1, T2])

	go func() {
		defer close(c)

		var v1 T1
		var v2 T2
		var closed = make([]bool, 2)
		var ok bool

		for {
			select {
			case v1, ok = <-it1:
				if !ok {
					closed[0] = true
				}
				v2, ok = <-it2
				if !ok {
					closed[1] = true
				}

			case v2, ok = <-it2:
				if !ok {
					closed[1] = true
				}
				v1, ok = <-it1
				if !ok {
					closed[0] = true
				}
			}

			if closed[0] || closed[1] {
				if (closed[0] && closed[1]) || !longest {
					return
				}
				if closed[0] {
					v1 = f1
				}
				if closed[1] {
					v2 = f2
				}
			}

			c <- Tuple2[T1, T2]{V1: v1, V2: v2}
		}
	}()

	return c
}

func Zip2[T1, T2 any](it1 <-chan T1, it2 <-chan T2) chan Tuple2[T1, T2] {
	var dummy1 T1
	var dummy2 T2
	return zip2(it1, it2, dummy1, dummy2, false)
}

func Zip2S[T1, T2 any](it1 []T1, it2 []T2) chan Tuple2[T1, T2] {
	c := make(chan Tuple2[T1, T2])
	l := Min(len(it1), len(it2))

	go func() {
		for i := 0; i < l; i++ {
			c <- Tuple2[T1, T2]{V1: it1[i], V2: it2[i]}
		}
		close(c)
	}()

	return c
}

func zip3[T1, T2, T3 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, f1 T1, f2 T2, f3 T3, longest bool) chan Tuple3[T1, T2, T3] {
	c := make(chan Tuple3[T1, T2, T3])

	go func() {
		defer close(c)

		var v1 T1
		var v2 T2
		var v3 T3
		var closed = make([]bool, 3)
		var ok bool

		for {
			select {
			case v1, ok = <-it1:
				if !ok {
					closed[0] = true
				}
				select {
				case v2, ok = <-it2:
					if !ok {
						closed[1] = true
					}
					v3, ok = <-it3
					if !ok {
						closed[2] = true
					}
				case v3, ok = <-it3:
					if !ok {
						closed[2] = true
					}
					v2, ok = <-it2
					if !ok {
						closed[1] = true
					}
				}
			case v2, ok = <-it2:
				if !ok {
					closed[1] = true
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						closed[0] = true
					}
					v3, ok = <-it3
					if !ok {
						closed[2] = true
					}
				case v3, ok = <-it3:
					if !ok {
						closed[2] = true
					}
					v1, ok = <-it1
					if !ok {
						closed[0] = true
					}
				}
			case v3, ok = <-it3:
				if !ok {
					closed[2] = true
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						closed[0] = true
					}
					v2, ok = <-it2
					if !ok {
						closed[1] = true
					}
				case v2, ok = <-it2:
					if !ok {
						closed[1] = true
					}
					v1, ok = <-it1
					if !ok {
						closed[0] = true
					}
				}
			}

			if closed[0] || closed[1] || closed[2] {
				if (closed[0] && closed[1] && closed[2]) || !longest {
					return
				}
				if closed[0] {
					v1 = f1
				}
				if closed[1] {
					v2 = f2
				}
				if closed[2] {
					v3 = f3
				}
			}

			c <- Tuple3[T1, T2, T3]{V1: v1, V2: v2, V3: v3}
		}
	}()

	return c
}

func Zip3[T1, T2, T3 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3) chan Tuple3[T1, T2, T3] {
	var dummy1 T1
	var dummy2 T2
	var dummy3 T3
	return zip3(it1, it2, it3, dummy1, dummy2, dummy3, false)
}

func Zip3S[T1, T2, T3 any](it1 []T1, it2 []T2, it3 []T3) chan Tuple3[T1, T2, T3] {
	c := make(chan Tuple3[T1, T2, T3])
	l := Min(len(it1), len(it2), len(it3))

	go func() {
		for i := 0; i < l; i++ {
			c <- Tuple3[T1, T2, T3]{V1: it1[i], V2: it2[i], V3: it3[i]}
		}
		close(c)
	}()

	return c
}

func zip4[T1, T2, T3, T4 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, it4 <-chan T4, f1 T1, f2 T2, f3 T3, f4 T4, longest bool) chan Tuple4[T1, T2, T3, T4] {
	c := make(chan Tuple4[T1, T2, T3, T4])

	go func() {
		defer close(c)

		var v1 T1
		var v2 T2
		var v3 T3
		var v4 T4
		var closed = make([]bool, 4)
		var ok bool

		for {
			select {
			case v1, ok = <-it1:
				if !ok {
					closed[0] = true
				}
				select {
				case v2, ok = <-it2:
					if !ok {
						closed[1] = true
					}
					select {
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					}
				case v3, ok = <-it3:
					if !ok {
						closed[2] = true
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					}
				case v4, ok = <-it4:
					if !ok {
						closed[3] = true
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					}
				}
			case v2, ok = <-it2:
				if !ok {
					closed[1] = true
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						closed[0] = true
					}
					select {
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					}
				case v3, ok = <-it3:
					if !ok {
						closed[2] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				case v4, ok = <-it4:
					if !ok {
						closed[3] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				}
			case v3, ok = <-it3:
				if !ok {
					closed[2] = true
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						closed[0] = true
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					}
				case v2, ok = <-it2:
					if !ok {
						closed[1] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v4, ok = <-it4
						if !ok {
							closed[3] = true
						}
					case v4, ok = <-it4:
						if !ok {
							closed[3] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				case v4, ok = <-it4:
					if !ok {
						closed[3] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				}
			case v4, ok = <-it4:
				if !ok {
					closed[3] = true
				}
				select {
				case v1, ok = <-it1:
					if !ok {
						closed[0] = true
					}
					select {
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					}
				case v2, ok = <-it2:
					if !ok {
						closed[1] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v3, ok = <-it3
						if !ok {
							closed[2] = true
						}
					case v3, ok = <-it3:
						if !ok {
							closed[2] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				case v3, ok = <-it3:
					if !ok {
						closed[2] = true
					}
					select {
					case v1, ok = <-it1:
						if !ok {
							closed[0] = true
						}
						v2, ok = <-it2
						if !ok {
							closed[1] = true
						}
					case v2, ok = <-it2:
						if !ok {
							closed[1] = true
						}
						v1, ok = <-it1
						if !ok {
							closed[0] = true
						}
					}
				}
			}

			if closed[0] || closed[1] || closed[2] || closed[3] {
				if (closed[0] && closed[1] && closed[2] && closed[3]) || !longest {
					return
				}
				if closed[0] {
					v1 = f1
				}
				if closed[1] {
					v2 = f2
				}
				if closed[2] {
					v3 = f3
				}
				if closed[3] {
					v4 = f4
				}
			}

			c <- Tuple4[T1, T2, T3, T4]{V1: v1, V2: v2, V3: v3, V4: v4}
		}
	}()

	return c
}

func Zip4[T1, T2, T3, T4 any](it1 <-chan T1, it2 <-chan T2, it3 <-chan T3, it4 <-chan T4) chan Tuple4[T1, T2, T3, T4] {
	var dummy1 T1
	var dummy2 T2
	var dummy3 T3
	var dummy4 T4
	return zip4(it1, it2, it3, it4, dummy1, dummy2, dummy3, dummy4, false)
}

func Zip4S[T1, T2, T3, T4 any](it1 []T1, it2 []T2, it3 []T3, it4 []T4) chan Tuple4[T1, T2, T3, T4] {
	c := make(chan Tuple4[T1, T2, T3, T4])
	l := Min(len(it1), len(it2), len(it3), len(it4))

	go func() {
		for i := 0; i < l; i++ {
			c <- Tuple4[T1, T2, T3, T4]{V1: it1[i], V2: it2[i], V3: it3[i], V4: it4[i]}
		}
		close(c)
	}()

	return c
}
